---
name: sample-api
structure:
  - title: d3fc-sample
    level: 1
    content: "A D3 component for down-sampling data using a variety of methods. Data is typically partitioned into equally-sized buckets, and one data point from each bucket is chosen. The algorithms employed here are Largest Triangle 1 (or 3) Bucket, or Mode-Median as detailed in the thesis [Downsampling Time Series for Visual Representation](http://skemman.is/stream/get/1946/15343/37285/3/SS_MSthesis.pdf).\r\n\r\n![d3fc sample](d3fc-sample.png)\r\n\r\nFor a live demo, see the [GitHub Pages site](http://d3fc.github.io/d3fc-sample/).\r\n\r\n"
    children:
      - title: API Reference
        level: 2
        content: "* [Mode Median](#mode-median)\r\n* [Largest Triangle One Bucket](#largest-triangle-one-bucket)\r\n* [Largest Triangle Three Buckets](#largest-triangle-three-buckets)\r\n* [Bucket](#bucket)\r\n\r\nThe sampling components provide an API for downsampling data. They are typically used to improve rendering performance of charts or maps when there is a significant amount of data. The data is passed to the component, which then returns a smaller downsampled array.\r\n\r\n```javascript\r\nimport {largestTriangleThreeBucket} from 'd3fc-sample';\r\n\r\n// Create the sampler\r\nconst sampler = largestTriangleThreeBucket();\r\n\r\n// Configure the x / y value accessors\r\nsampler.x(d => d.x)\r\n    .y(d => d.y);\r\n\r\n// Configure the size of the buckets used to downsample the data.\r\nsampler.bucketSize(10);\r\n\r\n// Run the sampler\r\nconst sampledData = sampler(data);\r\n```\r\n\r\n### Mode Median\r\n\r\nThe mode-median sampler is fairly basic. It partitions the data, then selects a representative piece of data from that set: the mode -- if it exists -- or the median.\r\n\r\n<a name=\"modeMedian\" href=\"#modeMedian\">#</a> fc.**modeMedian**()\r\n\r\nConstructs a new sampler.\r\n\r\n<a name=\"modeMedian_\" href=\"#modeMedian_\">#</a> *modeMedian*(*data*)\r\n\r\nRuns the sampler. It returns the downsampled data (it doesn't modify the `data` array itself). The downsampler selects the mode (if it exists), or the median value.\r\n\r\n<a name=\"modeMedian_value\" href=\"#modeMedian_value\">#</a> *modeMedian*.**value**(*accessorFunc*)\r\n\r\nSpecifies the accessor function used to obtain the value from the supplied array of data. The accessor function is invoked exactly once per datum, and should return the value to be down-sampled.\r\n\r\n<a name=\"modeMedian_bucketSize\" href=\"#modeMedian_bucketSize\">#</a> *modeMedian*.**bucketSize**(*size*)\r\n\r\nDenotes the amount of data points for each bucket. The first and last data points are always their own bucket. The second-last bucket will be of size `(data.length - 2) % size`.\r\n\r\n### Largest Triangle One Bucket\r\n\r\nLargest Triangle is a sampler where, given two pre-determined points, the point in the bucket that forms the largest triangle has the largest effective area and so is the most important in the bucket. The largest triangle algorithm comes in two flavours -- one bucket and three bucket. The algorithms are described in detail in the thesis [Downsampling Time Series for Visual Representation](http://skemman.is/stream/get/1946/15343/37285/3/SS_MSthesis.pdf), with a summary of their descriptions reproduced here:\r\n\r\n> This algorithm is very simple. First all the points are ranked by calculating their effective areas. Points with effective areas as null are excluded. The data points are then split up into approximately equal number of buckets as the specified downsample threshold. Finally, one point with the highest rank (largest effective area) is selected to represent each bucket in the downsampled data.\r\n\r\n> The effective area of a point is the area size of a triangle it forms with its two adjacent points.\r\n\r\n![largest triangle one bucket illustration](largest-triangle-one-bucket.png)\r\n\r\n<a name=\"largestTriangleOneBucket\" href=\"#largestTriangleOneBucket\">#</a> fc.**largestTriangleOneBucket**()\r\n\r\nConstructs a new sampler.\r\n\r\n<a name=\"largestTriangle_one\" href=\"#largestTriangle_one\">#</a>*largestTriangle*(*data*)\r\n\r\nRuns the sampler, returning the downsampled data (it doesn't modify the `data` array itself). The sampler selects the point in the bucket with the largest area between two other points (determined by algorithm).\r\n\r\n<a name=\"largestTriangle_x_one\" href=\"#largestTriangle_x_one\">#</a> *largestTriangle*.**x**(*accessorFunc*)\r\n\r\n<a name=\"largestTriangle_y_one\" href=\"#largestTriangle_y_one\">#</a> *largestTriangle*.**y**(*accessorFunc*)\r\n\r\nSpecifies the accessor function used to obtain the x and y values from the supplied array of data. The accessor function is invoked exactly once per datum, and should return the value to be down-sampled.\r\n\r\n<a name=\"largestTriangle_bucketSize_one\" href=\"#largestTriangle_bucketSize_one\">#</a> *largestTriangle*.**bucketSize**(*size*)\r\n\r\nDenotes the amount of data points for each bucket. The first and last data points are always their own bucket. The second-last bucket will be of size `(data.length - 2) % size`.\r\n\r\n\r\n### Largest Triangle Three Buckets\r\n\r\n> The algorithm is similar to the [above](#largest-triangle-one-bucket), except it works with three buckets at a time and proceeds from left to right. The first point which forms the left corner of the triangle (the effective area) is always fixed as the point that was previously selected and one of the points in the middle bucket shall be selected now.\r\n\r\nThe point used to form the triangle in the last bucket is a temporary point which is the average of all other points within that bucket.\r\n\r\n![largest triangle three bucket illustration](largest-triangle-three-bucket.png)\r\n\r\n<a name=\"largestTriangleThreeBucket\" href=\"#largestTriangleThreeBucket\">#</a> fc.**largestTriangleThreeBucket**()\r\n\r\nConstructs a new sampler.\r\n\r\n<a name=\"largestTriangle_three\" href=\"#largestTriangle_three\">#</a> *largestTriangle*(*data*)\r\n\r\nRuns the sampler, returning the downsampled data (it doesn't modify the `data` array itself). The sampler selects the point in the bucket with the largest area between two other points (determined by algorithm).\r\n\r\n<a name=\"largestTriangle_x_three\" href=\"#largestTriangle_x_three\">#</a> *largestTriangle*.**x**(*accessorFunc*)\r\n\r\n<a name=\"largestTriangle_y_three\" href=\"#largestTriangle_y_three\">#</a> *largestTriangle*.**y**(*accessorFunc*)\r\n\r\nSpecifies the accessor function used to obtain the x and y values from the supplied array of data. The accessor function is invoked exactly once per datum, and should return the value to be down-sampled.\r\n\r\n<a name=\"largestTriangle_bucketSize_three\" href=\"#largestTriangle_bucketSize_three\">#</a> *largestTriangle*.**bucketSize**(*size*)\r\n\r\nDenotes the amount of data points for each bucket. The first and last data points are always their own bucket. The second-last bucket will be of size `(data.length - 2) % size`.\r\n\r\n\r\n### Bucket\r\n\r\nd3fc-sample also comes with a data bucket utility, used by the algorithms. It partitions data into evenly-sized chunks, with the first and last bucket being their own.\r\n\r\n<a name=\"bucket\" href=\"#bucket\">#</a> fc.**bucket**()\r\n\r\nConstruct a data bucket utility instance.\r\n\r\n<a name=\"bucket_\" href=\"#bucket_\">#</a> *bucket*(*data*)\r\n\r\nPartitions the data into evenly sized buckets, in the form:\r\n\r\n```\r\n[\r\n    [data[0]],\r\n    [data[1], data[2], ..., data[n]],\r\n    [data[n + 1], data[n + 2], ..., data[2n]],\r\n    ...\r\n    [data[data.length - 1]]\r\n]\r\n```\r\n\r\n<a name=\"bucket_bucketSize\" href=\"#bucket_bucketSize\">#</a> *bucket*.**bucketSize**(*size*)\r\n\r\nDenotes the amount of data points for each bucket. The first and last data points are always their own bucket. The second-last bucket will be of size `(data.length - 2) % size`.\r\n"
layout: api
section: api
title: Sample

---
